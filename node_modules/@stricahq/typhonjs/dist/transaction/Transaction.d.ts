/// <reference types="node" />
import { Buffer } from "buffer";
import BigNumber from "bignumber.js";
import { CardanoAddress, CollateralInput, HashCredential, Mint, NativeScript, PlutusData, PlutusScriptType, ProtocolParams } from "../types";
import type { BipPath, AuxiliaryData, Certificate, Input, Output, Withdrawal, Token, VKeyWitness } from "../types";
export declare class Transaction {
    protected _protocolParams: ProtocolParams;
    protected inputs: Array<Input>;
    protected outputs: Array<Output>;
    protected certificates: Array<Certificate>;
    protected withdrawals: Array<Withdrawal>;
    protected requiredWitnesses: Map<string, BipPath | undefined>;
    protected requiredNativeScriptWitnesses: Map<string, undefined>;
    protected fee: BigNumber;
    protected ttl: number | undefined;
    protected witnesses: Array<VKeyWitness>;
    protected plutusScriptMap: Map<string, PlutusScriptType>;
    protected nativeScriptList: Array<NativeScript>;
    protected auxiliaryData: AuxiliaryData | undefined;
    protected collaterals: Array<CollateralInput>;
    protected requiredSigners: Map<string, BipPath | undefined>;
    protected plutusDataList: Array<PlutusData>;
    protected _isPlutusTransaction: boolean;
    protected mints: Array<Mint>;
    protected validityIntervalStart: number | undefined;
    constructor({ protocolParams }: {
        protocolParams: ProtocolParams;
    });
    get protocolParams(): ProtocolParams;
    getTTL(): number | undefined;
    setTTL(ttl: number): void;
    getValidityIntervalStart(): number | undefined;
    setValidityIntervalStart(validityIntervalStart: number): void;
    addInput(input: Input): void;
    addRequiredSigner(credential: HashCredential): void;
    addCollateral(input: CollateralInput): void;
    addMint(mint: Mint): void;
    addCertificate(certificate: Certificate): void;
    addOutput(output: Output): void;
    addWithdrawal(withdrawal: Withdrawal): void;
    protected transactionBody({ extraOutputs, scriptDataHash, }: {
        extraOutputs?: Array<Output>;
        scriptDataHash?: Buffer;
    }): unknown;
    private transactionFee;
    private contractFee;
    calculateTxSize(extraOutputs?: Array<Output>): number;
    calculateFee(extraOutputs?: Array<Output>): BigNumber;
    setFee(fee: BigNumber): void;
    getFee(): BigNumber;
    calculateMinUtxoAmount(tokens: Array<Token>, hasPlutusDataHash?: boolean): BigNumber;
    addWitness(witness: VKeyWitness): void;
    getTransactionHash(): Buffer;
    getAuxiliaryData(): AuxiliaryData | undefined;
    getAuxiliaryDataHashHex(): string | undefined;
    buildTransaction(): {
        hash: string;
        payload: string;
    };
    getInputs(): Array<Input>;
    getCertificates(): Array<Certificate>;
    getMints(): Array<Mint>;
    getMintTokens(): Array<Token>;
    getBurnTokens(): Array<Token>;
    getInputAmount(): {
        ada: BigNumber;
        tokens: Array<Token>;
    };
    getCollaterals(): Array<CollateralInput>;
    getScriptIntegrityHash(): Buffer | undefined;
    getCollateralAmount(): BigNumber;
    getOutputs(): Array<Output>;
    getOutputAmount(): {
        ada: BigNumber;
        tokens: Array<Token>;
    };
    getAdditionalOutputAda(): BigNumber;
    getAdditionalInputAda(): BigNumber;
    getWithdrawals(): Array<Withdrawal>;
    getRequiredWitnesses(): Map<string, BipPath | undefined>;
    getRequiredNativeScriptWitnesses(): Map<string, undefined>;
    getRequiredSigners(): Map<string, BipPath | undefined>;
    setAuxiliaryData(auxData: AuxiliaryData): void;
    isPlutusTransaction(): boolean;
    /**
     * Function to prepare transaction automatically
     * There are other helper methods for preparing transactions that use this method
     * This method should be used when you know what you are doing
     * sets required inputs,
     * fees,
     * change etc
     * resulting transaction is the final tx that can be built for signing
     */
    prepareTransaction({ inputs, changeAddress, collateralInputs, }: {
        inputs: Array<Input>;
        changeAddress: CardanoAddress;
        collateralInputs?: Array<CollateralInput>;
    }): Transaction;
    /**
     * Function for a simple send ADA transaction
     * Provide necessary outputs, and available inputs, returns a final tx
     */
    paymentTransaction({ inputs, outputs, changeAddress, auxiliaryData, ttl, }: {
        inputs: Array<Input>;
        outputs: Array<Output>;
        changeAddress: CardanoAddress;
        auxiliaryData?: AuxiliaryData;
        ttl: number;
    }): Transaction;
}
export default Transaction;
